-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Formula.Par where
import Formula.Abs
import Formula.Lex
import Formula.ErrM

}

%name pFormula Formula
%name pFormula2 Formula2
%name pFormula4 Formula4
%name pFormula5 Formula5
%name pFormula1 Formula1
%name pFormula3 Formula3
%name pBoolean Boolean
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '&' { PT _ (TS _ 2) }
  '&&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '->' { PT _ (TS _ 6) }
  '/\\' { PT _ (TS _ 7) }
  '<-' { PT _ (TS _ 8) }
  '<->' { PT _ (TS _ 9) }
  'F' { PT _ (TS _ 10) }
  'False' { PT _ (TS _ 11) }
  'G' { PT _ (TS _ 12) }
  'H' { PT _ (TS _ 13) }
  'O' { PT _ (TS _ 14) }
  'P' { PT _ (TS _ 15) }
  'R' { PT _ (TS _ 16) }
  'S' { PT _ (TS _ 17) }
  'T' { PT _ (TS _ 18) }
  'True' { PT _ (TS _ 19) }
  'U' { PT _ (TS _ 20) }
  'X' { PT _ (TS _ 21) }
  'Y' { PT _ (TS _ 22) }
  'Z' { PT _ (TS _ 23) }
  '\\/' { PT _ (TS _ 24) }
  '|' { PT _ (TS _ 25) }
  '||' { PT _ (TS _ 26) }

L_PIdent { PT _ (T_PIdent _) }


%%

PIdent    :: { PIdent} : L_PIdent { PIdent (mkPosToken $1)}

Formula :: { Formula }
Formula : Formula '->' Formula1 { Formula.Abs.Implies $1 $3 }
        | Formula '<-' Formula1 { Formula.Abs.Implied $1 $3 }
        | Formula '<->' Formula1 { Formula.Abs.Iff $1 $3 }
        | Formula1 { $1 }
Formula2 :: { Formula }
Formula2 : Formula2 'U' Formula3 { Formula.Abs.Until $1 $3 }
         | Formula2 'R' Formula3 { Formula.Abs.Release $1 $3 }
         | Formula2 'S' Formula3 { Formula.Abs.Since $1 $3 }
         | Formula2 'T' Formula3 { Formula.Abs.Triggered $1 $3 }
         | Formula2 '&' Formula3 { Formula.Abs.And $1 $3 }
         | Formula2 '&&' Formula3 { Formula.Abs.And $1 $3 }
         | Formula2 '/\\' Formula3 { Formula.Abs.And $1 $3 }
         | Formula2 '|' Formula3 { Formula.Abs.Or $1 $3 }
         | Formula2 '||' Formula3 { Formula.Abs.Or $1 $3 }
         | Formula2 '\\/' Formula3 { Formula.Abs.Or $1 $3 }
         | Formula3 { $1 }
Formula4 :: { Formula }
Formula4 : 'X' Formula4 { Formula.Abs.Next $2 }
         | 'F' Formula4 { Formula.Abs.Eventually $2 }
         | 'G' Formula4 { Formula.Abs.Always $2 }
         | 'Y' Formula4 { Formula.Abs.Yesterday $2 }
         | 'Z' Formula4 { Formula.Abs.Wyesterday $2 }
         | 'O' Formula4 { Formula.Abs.Once $2 }
         | 'P' Formula4 { Formula.Abs.Once $2 }
         | 'H' Formula4 { Formula.Abs.Historically $2 }
         | '!' Formula4 { Formula.Abs.Not $2 }
         | Formula5 { $1 }
Formula5 :: { Formula }
Formula5 : PIdent { Formula.Abs.Atom $1 }
         | Boolean { Formula.Abs.Bool $1 }
         | '(' Formula ')' { $2 }
Formula1 :: { Formula }
Formula1 : Formula2 { $1 }
Formula3 :: { Formula }
Formula3 : Formula4 { $1 }
Boolean :: { Boolean }
Boolean : 'True' { Formula.Abs.Boolean_True }
        | 'False' { Formula.Abs.Boolean_False }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

