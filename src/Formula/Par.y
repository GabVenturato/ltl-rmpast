-- Copyright (c) 2020 Gabriele Venturato
-- 
-- Permission is hereby granted, free of charge, to any person obtaining
-- a copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to
-- permit persons to whom the Software is furnished to do so, subject to
-- the following conditions:
-- 
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
-- 
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-- IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-- CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-- TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-- SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

--
-- This Happy file was machine-generated by the BNF converter, and later
-- slightly modified.
--

{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Formula.Par where
import qualified Formula.Abs
import Formula.Lex
}

%name pFormula Formula
%name pFormula2 Formula2
%name pFormula4 Formula4
%name pFormula5 Formula5
%name pFormula1 Formula1
%name pFormula3 Formula3
%name pBoolean Boolean
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '&' { PT _ (TS _ 2) }
  '&&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '->' { PT _ (TS _ 6) }
  '/\\' { PT _ (TS _ 7) }
  '<-' { PT _ (TS _ 8) }
  '<->' { PT _ (TS _ 9) }
  'F' { PT _ (TS _ 10) }
  'False' { PT _ (TS _ 11) }
  'G' { PT _ (TS _ 12) }
  'H' { PT _ (TS _ 13) }
  'O' { PT _ (TS _ 14) }
  'P' { PT _ (TS _ 15) }
  'R' { PT _ (TS _ 16) }
  'S' { PT _ (TS _ 17) }
  'T' { PT _ (TS _ 18) }
  'True' { PT _ (TS _ 19) }
  'U' { PT _ (TS _ 20) }
  'X' { PT _ (TS _ 21) }
  'Y' { PT _ (TS _ 22) }
  'Z' { PT _ (TS _ 23) }
  '\\/' { PT _ (TS _ 24) }
  '|' { PT _ (TS _ 25) }
  '||' { PT _ (TS _ 26) }
  L_Ident  { PT _ (TV $$) }

%%

Ident :: { Formula.Abs.Label }
Ident  : L_Ident { Formula.Abs.StringLabel $1 }

Formula :: { Formula.Abs.Formula }
Formula : Formula '->' Formula1 { Formula.Abs.Implies $1 $3 }
        | Formula '<-' Formula1 { Formula.Abs.Implied $1 $3 }
        | Formula '<->' Formula1 { Formula.Abs.Iff $1 $3 }
        | Formula1 { $1 }

Formula2 :: { Formula.Abs.Formula }
Formula2 : Formula2 'U' Formula3 { Formula.Abs.Until $1 $3 }
         | Formula2 'R' Formula3 { Formula.Abs.Release $1 $3 }
         | Formula2 'S' Formula3 { Formula.Abs.Since $1 $3 }
         | Formula2 'T' Formula3 { Formula.Abs.Triggered $1 $3 }
         | Formula2 '&' Formula3 { Formula.Abs.And $1 $3 }
         | Formula2 '&&' Formula3 { Formula.Abs.And $1 $3 }
         | Formula2 '/\\' Formula3 { Formula.Abs.And $1 $3 }
         | Formula2 '|' Formula3 { Formula.Abs.Or $1 $3 }
         | Formula2 '||' Formula3 { Formula.Abs.Or $1 $3 }
         | Formula2 '\\/' Formula3 { Formula.Abs.Or $1 $3 }
         | Formula3 { $1 }

Formula4 :: { Formula.Abs.Formula }
Formula4 : 'X' Formula4 { Formula.Abs.Next $2 }
         | 'F' Formula4 { Formula.Abs.Eventually $2 }
         | 'G' Formula4 { Formula.Abs.Always $2 }
         | 'Y' Formula4 { Formula.Abs.Yesterday $2 }
         | 'Z' Formula4 { Formula.Abs.Wyesterday $2 }
         | 'O' Formula4 { Formula.Abs.Once $2 }
         | 'P' Formula4 { Formula.Abs.Once $2 }
         | 'H' Formula4 { Formula.Abs.Historically $2 }
         | '!' Formula4 { Formula.Abs.Not $2 }
         | Formula5 { $1 }

Formula5 :: { Formula.Abs.Formula }
Formula5 : Ident { Formula.Abs.Atom $1 }
         | Boolean { Formula.Abs.Bool $1 }
         | '(' Formula ')' { $2 }

Formula1 :: { Formula.Abs.Formula }
Formula1 : Formula2 { $1 }

Formula3 :: { Formula.Abs.Formula }
Formula3 : Formula4 { $1 }

Boolean :: { Formula.Abs.Boolean }
Boolean : 'True' { Formula.Abs.BooleanTrue }
        | 'False' { Formula.Abs.BooleanFalse }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}